'''
Descripttion: 111
version: 
Author: xxh
Date: 2021-11-13
'''
import unittest
from typing import List

from z3 import *

# In this problem, you will implement the DPLL algorithm as discussed
# in the class.


# a utility class to represent the code you should fill in.
class Todo(Exception):
    def __init__(self, msg):
        self.msg = msg

    def __str__(self):
        return self.msg

    def __repr__(self):
        return self.__str__()


########################################
# This bunch of code declare the syntax for the propositional logic, we
# repeat here:
'''
P ::= p
    | T
    | F
    | P /\ P
    | P \/ P
    | P -> P
    | ~P
'''


class Prop:
    def __repr__(self):
        return self.__str__()


class PropVar(Prop):
    def __init__(self, var):
        self.var = var

    def __str__(self):
        return self.var

    def __hash__(self):
        return hash(self.var)

    def __eq__(self, other):
        return other.__class__ == self.__class__ and self.var == other.var


class PropTrue(Prop):
    def __init__(self):
        pass

    def __str__(self):
        return "True"

    def __eq__(self, other):
        return other.__class__ == self.__class__


class PropFalse(Prop):
    def __init__(self):
        pass

    def __str__(self):
        return "False"

    def __eq__(self, other):
        return other.__class__ == self.__class__


class PropAnd(Prop):
    def __init__(self, left, right):
        self.left = left
        self.right = right

    def __str__(self):
        return f"({self.left} /\\ {self.right})"


class PropOr(Prop):
    def __init__(self, left, right):
        self.left = left
        self.right = right

    def __str__(self):
        return f"({self.left} \\/ {self.right})"


class PropImplies(Prop):
    def __init__(self, left, right):
        self.left = left
        self.right = right

    def __str__(self):
        return f"({self.left} -> {self.right})"


class PropNot(Prop):
    def __init__(self, p):
        self.p = p

    def __str__(self):
        return f"~{self.p}"


# we can convert the above defined syntax into Z3's representation, so
# that we can check it's validity easily:
def to_z3(prop):
    if isinstance(prop, PropVar):
        return Bool(prop.var)
    if isinstance(prop, PropImplies):
        return Implies(to_z3(prop.left), to_z3(prop.right))
    if isinstance(prop,PropAnd):
        return And(to_z3(prop.left),to_z3(prop.right))
    if isinstance(prop,PropOr):
        return Or(to_z3(prop.left),to_z3(prop.right))
    if isinstance(prop,PropNot):
        return Not(to_z3(prop.p))
    if isinstance(prop,PropTrue):
        return True
    if isinstance(prop,PropFalse):
        return False

    # raise Todo("Exercise 3-1: try to complete the `to_z3` method")


#####################
# TODO: please implement the nnf(), cnf() and dpll() algorithm, as discussed
# in the class.
def nnf(prop: Prop) -> Prop:
    if is_atom(prop):
        return prop
    else:
        if isinstance(prop, PropImplies):
            return PropOr(PropNot(prop.left),nnf(prop.right))
        if isinstance(prop,PropNot):
            if isinstance(prop.p,PropAnd):
                return PropOr(nnf(PropNot(prop.p.left)),nnf(PropNot(prop.p.right)))
            if isinstance(prop.p,PropOr):
                return PropAnd(nnf(PropNot(prop.p.left)),nnf(PropNot(prop.p.right)))
            if isinstance(prop.p, PropNot):
                return nnf(prop.p.p)
            return prop
        if isinstance(prop,PropOr):
            return prop
        if isinstance(prop,PropAnd):
            return prop
    # raise Todo("Exercise 3-2: try to implement the `nnf` method")


def is_atom(nnf_prop: Prop) -> bool:
    if isinstance(nnf_prop, PropVar) :
        return True
    return False


def cnf(nnf_prop: Prop) -> Prop:
    def cnf_d(left: Prop, right: Prop) -> Prop:
        pass
    if is_atom(nnf_prop):
        return nnf_prop
    if isinstance(nnf_prop,PropOr) and isinstance(nnf_prop.left,PropAnd):
        return PropAnd(cnf(PropOr(nnf_prop.left.left,nnf_prop.right)),cnf(PropOr(nnf_prop.left.right,nnf_prop.right)))
    if isinstance(nnf_prop,PropOr) and isinstance(nnf_prop.right,PropAnd):
        return PropAnd(cnf(PropOr(nnf_prop.left,nnf_prop.right.left)),cnf(PropOr(nnf_prop.left,nnf_prop.right.right)))
    return nnf_prop
    
    # raise Todo("Exercise 3-3: try to implement the `cnf`and `cnf_d` method")


def flatten(cnf_prop: Prop) -> List[List[Prop]]:
    """Flatten CNF Propositions to nested list structure .

    The CNF Propositions generated by `cnf` method is AST.
    This method can flatten the AST to a nested list of Props.
    For example: "((~p1 \\/ ~p3) /\\ (~p1 \\/ p4))" can be
    transfer to "[[~p1, ~p3], [~p1, p4]]".

    Parameters
    ----------
    cnf_prop : Prop
        CNF Propositions generated by `cnf` method.

    Returns
    -------
    List[List[Prop]
        A nested list of Props, first level lists are connected by `And`,
        and second level lists is connected by `Or`.

    """

    def get_atom_from_disjunction(prop: Prop) -> List[Prop]:
        if is_atom(prop):
            return [prop]
        if isinstance(prop,PropNot):
            return [prop]
        if isinstance(prop, PropOr):
            return get_atom_from_disjunction(prop.left) + get_atom_from_disjunction(prop.right)

    if isinstance(cnf_prop, PropAnd):
        return flatten(cnf_prop.left) + flatten(cnf_prop.right)
    elif isinstance(cnf_prop, PropOr):
        return [get_atom_from_disjunction(cnf_prop)]
    elif is_atom(cnf_prop):
        return [[cnf_prop]]
    elif isinstance(cnf_prop,PropNot):
        return [cnf_prop]

import functools
import copy 
import threading
import _thread
import time
import sys
flag = False
sv = {} 
def dpll(prop: Prop) -> dict:
    def conj(a:list,b:list)->list:
        c = []
        if a.__len__()==0:
            return b
        if(b.__len__()==1):
            c = [a[0] or b[0],a[1] or b[0]]
        else: 
            c = [a[0] or b[0],a[1] or b[1]]
        return  c

    def getRes(elems:List) -> dict:
        res = {}
        ret = True
        while(elems.__len__()>0):
            elem = elems[0]
            del elems[0]
            t = [False,False]
            print("当前处理元素： ",elem)
            for e in elem:
                #先赋值
                if isinstance(e,PropVar) and (str(e) in res):
                    t = conj(t,res[str(e)])
                    elem.remove(e)
                if isinstance(e,PropNot) and (str(e.p) in res):
                    t = conj(t,res[str(e.p)])
                    elem.remove(e)
            print("1",res,elem)
            if t == [True,True]: #任意取值
                for e in elem:
                    if isinstance(e,PropVar):
                        res[str(e)] = [True,False]
                    if isinstance(e,PropNot):
                        res[str(e.p)] = [True,False]
                continue
            if elem.__len__()==0:
                continue
            if elem.__len__()==1:
                if isinstance(elem[0],PropVar):
                    res[str(elem[0])] = [True,True]
                if isinstance(elem[0],PropNot):
                    # print("e.p = ",str(e),str(e.p))
                    res[str(elem[0].p)] = [True,True]
                continue
            r = []
            for e in elem:
                #确定值
                if isinstance(e,PropVar):
                    res[str(e)] = r
                    r = conj(r,res[str(e)])
                if isinstance(e,PropNot):
                    res[str(e.p)] = [not r[0],not r[1]]
                    r = conj(r,res[str(e.p)])
            print("2",res)
            print("处理完成")
            ret = ret and t

        if ret ==True:
            return res
        else:
            return "unsat"

    
    def currCal(elems:list,res:dict):
        global flag
        global sv
        if flag ==True:
            return 
        t = False
        for elem in elems:#已有的值
            if elem.__len__()==0:
                elems.remove(elem)
            for e in elem:
                if isinstance(e,PropVar) and str(e) in res:
                    t = t or res[str(e)]
                    elem.remove(e)
                if isinstance(e,PropNot) and str(e.p) in res:
                    t = t or res[str(e.p)]
                    elem.remove(e)
            if elem.__len__()==0:
                elems.remove(elem)
        
        if elems.__len__()==0:
            sv = res
            flag = True
        
        if t == True:
            for elem in elems:#未存在的值
                for e in elem:
                    if isinstance(e,PropVar):
                        res[str(e)] = True
                        _thread.start_new_thread(currCal,(copy.deepcopy(elems),copy.deepcopy(res)))
                        res[str(e)] = False
                        _thread.start_new_thread(currCal,(copy.deepcopy(elems),copy.deepcopy(res)))
                    if isinstance(e,PropNot):
                        res[str(e.p)] = True
                        _thread.start_new_thread(currCal,(copy.deepcopy(elems),copy.deepcopy(res)))
                        res[str(e.p)] = False
                        _thread.start_new_thread(currCal,(copy.deepcopy(elems),copy.deepcopy(res)))
        else:
            for elem in elems:#未存在的值
                for e in elem:
                    if isinstance(e,PropVar):
                        res[str(e)] = True
                        _thread.start_new_thread(currCal,(copy.deepcopy(elems),copy.deepcopy(res)))
                    if isinstance(e,PropNot):
                        res[str(e.p)] = False
                        _thread.start_new_thread(currCal,(copy.deepcopy(elems),copy.deepcopy(res)))
        

    def dfs(elems:list,level:int,res:dict):
        global flag
        global sv
        if  flag or level >= elems.__len__():
            flag = True
            if sv.__len__()==0:
                sv = res
            return 
        t = False
        elemList = elems[level]
        for elem in elemList:#已有的值
            if isinstance(elem,PropVar) and str(elem) in res:
                t = t or res[str(elem)]
                elemList.remove(elem)
            if isinstance(elem,PropNot) and str(elem.p) in res:
                t = t or res[str(elem.p)]
                elemList.remove(elem)

        if t == True:
            for elem in elemList:#未存在的值
                if isinstance(elem,PropVar) and str(elem) not in res:
                    res[str(elem)] = True
                    dfs(elems,level,res)
                    res[str(elem)] = False
                    dfs(elems,level,res)
                    del res[str(elem)]
                if isinstance(elem,PropNot) and str(elem.p) not in res:
                    res[str(elem.p)] = True
                    dfs(elems,level,res)
                    res[str(elem.p)] = False
                    dfs(elems,level,res)
                    del res[str(elem.p)]
        else:
            for elem in elemList:
                if isinstance(elem,PropVar) and str(elem) not in res:
                    res[str(elem)] = True
                if isinstance(elem,PropNot) and str(elem.p) not in res:
                    res[str(elem.p)] = False
        dfs(elems,level+1,res)

    def cmp(a,b):
        return a.__len__()>b.__len__()
    
    flatten_cnf = flatten(cnf(nnf(prop)))
    flatten_cnf.sort(key = functools.cmp_to_key(cmp))
    test_run = copy.deepcopy(flatten_cnf)
    res = {}
    global sv
    global flag
    sv.clear()
    flag = False
    # dfs(test_run,0,res)
    currCal(test_run,res)
    time.sleep(0.1)
    return sv
    

    
    
    


        


    # implement the dpll algorithm we've discussed in the lecture
    # you can deal with flattened cnf which generated by `flatten` method for convenience,
    # or, as another choice, you can process the original cnf destructure generated by `cnf` method
    #
    # your implementation should output the result as dict like :
    # {"p1": True, "p2": False, "p3": False, "p4": True} if there is solution;
    # output "unsat" if there is no solution
    #
    # feel free to add new method.



    # raise Todo("Exercise 3-4: try to implement the `dpll` algorithm")


#####################
# test cases:

# p -> (q -> p)
test_prop_1 = PropImplies(PropVar('p'), PropImplies(PropVar('q'), PropVar('p')))

# ~((p1 \/ ~p2) /\ (p3 \/ ~p4))
test_prop_2 = PropNot(PropAnd(
    PropOr(PropVar("p1"), PropNot(PropVar("p2"))),
    PropOr(PropVar("p3"), PropNot(PropVar("p4")))
))

test_prop_my = PropAnd(PropVar("p1"),PropOr(PropVar("p3"),PropVar("p2")))
# #####################
class TestDpll(unittest.TestCase):

    def test_to_z3_1(self):
        self.assertEqual(str(to_z3(test_prop_1)), "Implies(p, Implies(q, p))")

    def test_to_z3_2(self):
        self.assertEqual(str(to_z3(test_prop_2)), "Not(And(Or(p1, Not(p2)), Or(p3, Not(p4))))")

    def test_nnf_1(self):
        print(nnf(test_prop_1))
        self.assertEqual(str(nnf(test_prop_1)), "(~p \\/ (~q \\/ p))")

    def test_nnf_2(self):
        print(nnf(test_prop_2))
        self.assertEqual(str(nnf(test_prop_2)), "((~p1 /\\ p2) \\/ (~p3 /\\ p4))")

    def test_cnf_1(self):
        self.assertEqual(str(cnf(nnf(test_prop_1))), "(~p \\/ (~q \\/ p))")

    def test_cnf_2(self):
        print(str(cnf(nnf(test_prop_2))))
        self.assertEqual(str(cnf(nnf(test_prop_2))),
                         "(((~p1 \\/ ~p3) /\\ (~p1 \\/ p4)) /\\ ((p2 \\/ ~p3) /\\ (p2 \\/ p4)))")

    def test_cnf_flatten_1(self):
        print(str(flatten(cnf(nnf(test_prop_1)))))
        self.assertEqual(str(flatten(cnf(nnf(test_prop_1)))), "[[~p, ~q, p]]")

    def test_cnf_flatten_2(self):
        print(type(flatten(cnf(nnf(test_prop_2)))[0][0]))
        self.assertEqual(str(flatten(cnf(nnf(test_prop_2)))),
                         "[[~p1, ~p3], [~p1, p4], [p2, ~p3], [p2, p4]]")


    def test_dpll_my(self):
        s = Solver()
        res = dpll(test_prop_my)
        # s.add(Not(And(res["p1"], res["p2"])))
        s.add(Not(And(res["p1"],Or(res["p3"],res["p2"]))))
        self.assertEqual(str(s.check()), "unsat")

    def test_dpll_1(self):
        s = Solver()
        res = dpll(test_prop_1)
        s.add(Not(Implies(res["p"], Implies(res["q"], res["p"]))))
        self.assertEqual(str(s.check()), "unsat")

    def test_dpll_2(self):
        s = Solver()
        res = dpll(test_prop_2)
        s.add(Not(Not(And(Or(res["p1"], Not(res["p2"])), Or(res["p3"], Not(res["p4"]))))))
        self.assertEqual(str(s.check()), "unsat")


if __name__ == '__main__':
    unittest.main()
